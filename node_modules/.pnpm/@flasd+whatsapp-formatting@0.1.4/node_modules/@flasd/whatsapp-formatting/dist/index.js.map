{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["export type Wildcard = \"*\" | \"~\" | \"_\" | \"```\" | string;\n\nexport interface IRule {\n  wildcard: Wildcard;\n  openTag: string;\n  closeTag: string;\n}\n\nfunction isAplhanumeric(char: any): boolean {\n  const x: number = `${char || \"\"}`.charCodeAt(0);\n\n  if (!char || Number.isNaN(x)) {\n    return false;\n  }\n\n  return !!(\n    (x >= 65 && x <= 90)\n    || (x >= 97 && x <= 122)\n    || (x >= 48 && x <= 57)\n  );\n}\n\nfunction getIndexes(text: string, wildcard: Wildcard): number[] {\n  const indices: number[] = [];\n\n  for (let i = 0; i < text.length; i += 1) {\n    if (text[i] === wildcard) {\n      if (indices.length % 2) {\n        if (\n          text[i - 1] === \" \"\n          || isAplhanumeric(text[i + 1])\n        ) {\n          break;\n        } else {\n          indices.push(i);\n        }\n      } else if (\n          typeof (text[i + 1]) === \"undefined\"\n          || text[i + 1] === \" \"\n          || isAplhanumeric(text[i - 1])\n          ) {\n        break;\n      } else {\n        indices.push(i);\n      }\n    } else if (text[i].charCodeAt(0) === 10 && indices.length % 2) {\n      indices.pop();\n    }\n  }\n\n  if (indices.length % 2) {\n    // we have unclosed tags\n    indices.pop();\n  }\n\n  return indices;\n}\n\nfunction injectTags(text: string, indices: number[], rule: IRule): string {\n  let e = 0;\n\n  indices.forEach((value, index) => {\n    const tag = (index % 2)\n      ? rule.closeTag\n      : rule.openTag;\n\n    let v = value;\n    v += e;\n\n    text = text.substr(0, v) + tag + text.substr(v + 1);\n\n    e += (tag.length - 1);\n  });\n\n  return text;\n}\n\nfunction execRule(text: string, rule: IRule): string {\n  const indices: number[] = getIndexes(text, rule.wildcard);\n  return injectTags(text, indices, rule);\n}\n\nfunction parseText(text: string, rules: IRule[]): string {\n  const final: string = rules.reduce(\n    (transformed, rule) => {\n      return execRule(transformed, rule);\n    },\n   text,\n  );\n\n  return final.replace(/\\n/gi, \"<br>\");\n}\n\nexport const whatsappRules: IRule[] = [\n  {\n    closeTag: \"</strong>\",\n    openTag: \"<strong>\",\n    wildcard: \"*\",\n  },\n  {\n    closeTag: \"</i>\",\n    openTag: \"<i>\",\n    wildcard: \"_\",\n  },\n  {\n    closeTag: \"</s>\",\n    openTag: \"<s>\",\n    wildcard: \"~\",\n  },\n];\n\nexport function format(text: string, rules?: IRule[]) {\n  return parseText(text, rules || whatsappRules);\n}\n"],"names":["isAplhanumeric","char","x","charCodeAt","Number","isNaN","whatsappRules","closeTag","openTag","wildcard","format","text","rules","reduce","transformed","rule","indices","i","length","push","pop","getIndexes","e","forEach","value","index","tag","v","substr","injectTags","execRule","replace","parseText"],"mappings":"AAQA,SAASA,EAAeC,GACtB,IAAMC,OAAeD,GAAQ,KAAKE,WAAW,GAE7C,SAAKF,GAAQG,OAAOC,MAAMH,MAKvBA,GAAK,IAAMA,GAAK,IACbA,GAAK,IAAMA,GAAK,KAChBA,GAAK,IAAMA,GAAK,KA2EXI,IAAAA,EAAyB,CACpC,CACEC,SAAU,YACVC,QAAS,WACTC,SAAU,KAEZ,CACEF,SAAU,OACVC,QAAS,MACTC,SAAU,KAEZ,CACEF,SAAU,OACVC,QAAS,MACTC,SAAU,eAIEC,EAAOC,EAAcC,GACnC,OA9BF,SAAmBD,EAAcC,GAQ/B,OAPsBA,EAAMC,OAC1B,SAACC,EAAaC,GACZ,OARN,SAAkBJ,EAAcI,GAC9B,IAAMC,EAxDR,SAAoBL,EAAcF,GAGhC,IAFA,IAAMO,EAAoB,GAEjBC,EAAI,EAAGA,EAAIN,EAAKO,OAAQD,GAAK,EACpC,GAAIN,EAAKM,KAAOR,EACd,GAAIO,EAAQE,OAAS,EAAG,CACtB,GACkB,MAAhBP,EAAKM,EAAI,IACNjB,EAAeW,EAAKM,EAAI,IAE3B,MAEAD,EAAQG,KAAKF,gBAGY,IAAjBN,EAAKM,EAAI,IACE,MAAhBN,EAAKM,EAAI,IACTjB,EAAeW,EAAKM,EAAI,IAE7B,MAEAD,EAAQG,KAAKF,QAEoB,KAA1BN,EAAKM,GAAGd,WAAW,IAAaa,EAAQE,OAAS,GAC1DF,EAAQI,MASZ,OALIJ,EAAQE,OAAS,GAEnBF,EAAQI,MAGHJ,EAuBmBK,CAAWV,EAAMI,EAAKN,UAChD,OArBF,SAAoBE,EAAcK,EAAmBD,GACnD,IAAIO,EAAI,EAeR,OAbAN,EAAQO,QAAQ,SAACC,EAAOC,GACtB,IAAMC,EAAOD,EAAQ,EACjBV,EAAKR,SACLQ,EAAKP,QAELmB,EAAIH,EAGRb,EAAOA,EAAKiB,OAAO,EAFnBD,GAAKL,GAEsBI,EAAMf,EAAKiB,OAAOD,EAAI,GAEjDL,GAAMI,EAAIR,OAAS,IAGdP,EAKAkB,CAAWlB,EAAMK,EAASD,GAMtBe,CAAShB,EAAaC,IAEhCJ,GAGYoB,QAAQ,OAAQ,QAsBtBC,CAAUrB,EAAMC,GAASN"}