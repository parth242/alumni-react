{"version":3,"file":"utils.cjs.development.js","sources":["../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/constants.ts","../src/getUiOptions.ts","../src/canExpand.ts","../src/deepEquals.ts","../src/findSchemaDefinition.ts","../src/schema/getMatchingOption.ts","../src/guessType.ts","../src/getSchemaType.ts","../src/isFixedItems.ts","../src/mergeDefaultsWithFormData.ts","../src/mergeObjects.ts","../src/isConstant.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/isCustomWidget.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/createSchemaUtils.ts","../src/dataURItoBlob.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../src/getWidget.tsx","../src/hasWidget.ts","../src/localToUTC.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/processSelectValue.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/utcToLocal.ts"],"sourcesContent":["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n","import isObject from \"./isObject\";\nimport { RJSFSchema } from \"./types\";\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems(schema: RJSFSchema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === \"\") {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nexport const ADDITIONAL_PROPERTIES_KEY = \"additionalProperties\";\nexport const ALL_OF_KEY = \"allOf\";\nexport const ANY_OF_KEY = \"anyOf\";\nexport const CONST_KEY = \"const\";\nexport const DEFAULT_KEY = \"default\";\nexport const DEFINITIONS_KEY = \"definitions\";\nexport const DEPENDENCIES_KEY = \"dependencies\";\nexport const ENUM_KEY = \"enum\";\nexport const ERRORS_KEY = \"__errors\";\nexport const ID_KEY = \"$id\";\nexport const ITEMS_KEY = \"items\";\nexport const NAME_KEY = \"$name\";\nexport const ONE_OF_KEY = \"oneOf\";\nexport const PROPERTIES_KEY = \"properties\";\nexport const REQUIRED_KEY = \"required\";\nexport const SUBMIT_BTN_OPTIONS_KEY = \"submitButtonOptions\";\nexport const REF_KEY = \"$ref\";\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = \"__rjsf_additionalProperties\";\nexport const UI_FIELD_KEY = \"ui:field\";\nexport const UI_WIDGET_KEY = \"ui:widget\";\nexport const UI_OPTIONS_KEY = \"ui:options\";\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from \"./constants\";\nimport isObject from \"./isObject\";\nimport { UIOptionsType, UiSchema } from \"./types\";\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @returns - An object containing all of the `ui:xxx` options with the stripped off\n */\nexport default function getUiOptions<T = any, F = any>(\n  uiSchema: UiSchema<T, F> = {}\n): UIOptionsType<T, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf(\"ui:\") === 0)\n    .reduce((options, key) => {\n      const value = uiSchema[key];\n      if (key === UI_WIDGET_KEY && isObject(value)) {\n        console.error(\n          \"Setting options via ui:widget object is no longer supported, use ui:options instead\"\n        );\n        return options;\n      }\n      if (key === UI_OPTIONS_KEY && isObject(value)) {\n        return { ...options, ...value };\n      }\n      return { ...options, [key.substring(3)]: value };\n    }, {});\n}\n","import { RJSFSchema, UiSchema } from \"./types\";\nimport getUiOptions from \"./getUiOptions\";\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, F = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","import isEqualWith from \"lodash/isEqualWith\";\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === \"function\" && typeof other === \"function\") {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import jsonpointer from \"jsonpointer\";\nimport omit from \"lodash/omit\";\n\nimport { REF_KEY } from \"./constants\";\nimport { GenericObjectType, RJSFSchema } from \"./types\";\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(\n  key: string,\n  object: GenericObjectType\n) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition(\n  $ref?: string,\n  rootSchema: RJSFSchema = {}\n): RJSFSchema {\n  let ref = $ref || \"\";\n  if (ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: RJSFSchema = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n","import { RJSFSchema, ValidatorType } from \"../types\";\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the matched option or 0 if none is available\n */\nexport default function getMatchingOption<T = any>(\n  validator: ValidatorType,\n  formData: T | undefined,\n  options: RJSFSchema[],\n  rootSchema: RJSFSchema\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n  if (typeof value === \"string\") {\n    return \"string\";\n  }\n  if (value == null) {\n    return \"null\";\n  }\n  if (typeof value === \"boolean\") {\n    return \"boolean\";\n  }\n  if (!isNaN(value)) {\n    return \"number\";\n  }\n  if (typeof value === \"object\") {\n    return \"object\";\n  }\n  // Default to string if we can't figure it out\n  return \"string\";\n}\n","import guessType from \"./guessType\";\nimport { RJSFSchema } from \"./types\";\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType(\n  schema: RJSFSchema\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes(\"null\")) {\n    type = type.find((type) => type !== \"null\");\n  }\n\n  return type;\n}\n","import isObject from \"./isObject\";\nimport { RJSFSchema } from \"./types\";\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems(schema: RJSFSchema) {\n  return (\n    Array.isArray(schema.items) &&\n    schema.items.length > 0 &&\n    schema.items.every((item) => isObject(item))\n  );\n}\n","import get from \"lodash/get\";\n\nimport isObject from \"./isObject\";\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param defaults - The defaults to merge\n * @param formData - The form data into which the defaults will be merged\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults: T,\n  formData: T\n): T {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value);\n      }\n      return value;\n    });\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    // eslint-disable-next-line no-unused-vars\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key)\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from \"./isObject\";\nimport { GenericObjectType } from \"./types\";\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import { CONST_KEY } from \"./constants\";\nimport { RJSFSchema } from \"./types\";\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant(schema: RJSFSchema) {\n  return (\n    (Array.isArray(schema.enum) && schema.enum.length === 1) ||\n    CONST_KEY in schema\n  );\n}\n","import union from \"lodash/union\";\n\nimport { REQUIRED_KEY } from \"./constants\";\nimport getSchemaType from \"./getSchemaType\";\nimport isObject from \"./isObject\";\nimport { GenericObjectType } from \"./types\";\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType\n) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import get from \"lodash/get\";\nimport set from \"lodash/set\";\nimport mergeAllOf from \"json-schema-merge-allof\";\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  DEPENDENCIES_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport findSchemaDefinition, {\n  splitKeyElementFromObject,\n} from \"../findSchemaDefinition\";\nimport guessType from \"../guessType\";\nimport isObject from \"../isObject\";\nimport mergeSchemas from \"../mergeSchemas\";\nimport {\n  GenericObjectType,\n  RJSFSchema,\n  RJSFSchemaDefinition,\n  ValidatorType,\n} from \"../types\";\nimport getMatchingOption from \"./getMatchingOption\";\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param formData - The current formData to assist retrieving a schema\n * @returns - A schema with the appropriate condition resolved\n */\nexport function resolveCondition<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  formData: T\n) {\n  const {\n    if: expression,\n    then,\n    else: otherwise,\n    ...resolvedSchemaLessConditional\n  } = schema;\n\n  const conditionalSchema = validator.isValid(\n    expression as RJSFSchema,\n    formData,\n    rootSchema\n  )\n    ? then\n    : otherwise;\n\n  if (conditionalSchema && typeof conditionalSchema !== \"boolean\") {\n    return retrieveSchema<T>(\n      validator,\n      mergeSchemas(\n        resolvedSchemaLessConditional,\n        retrieveSchema(validator, conditionalSchema, rootSchema, formData)\n      ),\n      rootSchema,\n      formData\n    );\n  }\n  return retrieveSchema<T>(\n    validator,\n    resolvedSchemaLessConditional,\n    rootSchema,\n    formData\n  );\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children.\n * Called internally by retrieveSchema.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references and dependencies resolved\n */\nexport function resolveSchema<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema = {},\n  formData?: T\n): RJSFSchema {\n  if (REF_KEY in schema) {\n    return resolveReference<T>(validator, schema, rootSchema, formData);\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T>(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return retrieveSchema<T>(validator, resolvedSchema, rootSchema, formData);\n  }\n  if (ALL_OF_KEY in schema) {\n    return {\n      ...schema,\n      allOf: schema.allOf!.map((allOfSubschema) =>\n        retrieveSchema<T>(\n          validator,\n          allOfSubschema as RJSFSchema,\n          rootSchema,\n          formData\n        )\n      ),\n    };\n  }\n  // No $ref or dependencies attribute found, returning the original schema.\n  return schema;\n}\n\n/** Resolves references within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references resolved\n */\nexport function resolveReference<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  formData?: T\n): RJSFSchema {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema<T>(\n    validator,\n    { ...$refSchema, ...localSchema },\n    rootSchema,\n    formData\n  );\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<T = any>(\n  validator: ValidatorType,\n  theSchema: RJSFSchema,\n  rootSchema?: RJSFSchema,\n  aFormData?: T\n): RJSFSchema {\n  // Clone the schema so we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType =\n    aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: RJSFSchema = {};\n    if (typeof schema.additionalProperties !== \"boolean\") {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) },\n          rootSchema,\n          formData as T\n        );\n      } else if (\"type\" in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema = {},\n  rawFormData?: T\n): RJSFSchema {\n  if (!isObject(schema)) {\n    return {};\n  }\n  let resolvedSchema = resolveSchema<T>(\n    validator,\n    schema,\n    rootSchema,\n    rawFormData\n  );\n\n  if (\"if\" in schema) {\n    return resolveCondition<T>(validator, schema, rootSchema, rawFormData as T);\n  }\n\n  const formData: GenericObjectType = rawFormData || {};\n  // For each level of the dependency, we need to recursively determine the appropriate resolved schema given the current state of formData.\n  // Otherwise, nested allOf subschemas will not be correctly displayed.\n  if (resolvedSchema.properties) {\n    const properties: GenericObjectType = {};\n\n    Object.entries(resolvedSchema.properties).forEach((entries) => {\n      const propName = entries[0];\n      const propSchema = entries[1] as RJSFSchema;\n      const rawPropData = formData[propName];\n      const propData = isObject(rawPropData) ? rawPropData : {};\n      const resolvedPropSchema = retrieveSchema<T>(\n        validator,\n        propSchema,\n        rootSchema,\n        propData\n      );\n\n      properties[propName] = resolvedPropSchema;\n\n      if (\n        propSchema !== resolvedPropSchema &&\n        resolvedSchema.properties !== properties\n      ) {\n        resolvedSchema = { ...resolvedSchema, properties };\n      }\n    });\n  }\n\n  if (ALL_OF_KEY in schema) {\n    try {\n      resolvedSchema = mergeAllOf({\n        ...resolvedSchema,\n        allOf: resolvedSchema.allOf,\n      });\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n  const hasAdditionalProperties =\n    ADDITIONAL_PROPERTIES_KEY in resolvedSchema &&\n    resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties<T>(\n      validator,\n      resolvedSchema,\n      rootSchema,\n      formData as T\n    );\n  }\n  return resolvedSchema;\n}\n\n/** Resolves dependencies within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with its dependencies resolved\n */\nexport function resolveDependencies<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  formData?: T\n): RJSFSchema {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  let resolvedSchema = remainingSchema;\n  if (Array.isArray(resolvedSchema.oneOf)) {\n    resolvedSchema = resolvedSchema.oneOf[\n      getMatchingOption<T>(\n        validator,\n        formData,\n        resolvedSchema.oneOf as RJSFSchema[],\n        rootSchema\n      )\n    ] as RJSFSchema;\n  } else if (Array.isArray(resolvedSchema.anyOf)) {\n    resolvedSchema = resolvedSchema.anyOf[\n      getMatchingOption<T>(\n        validator,\n        formData,\n        resolvedSchema.anyOf as RJSFSchema[],\n        rootSchema\n      )\n    ] as RJSFSchema;\n  }\n  return processDependencies<T>(\n    validator,\n    dependencies,\n    resolvedSchema,\n    rootSchema,\n    formData\n  );\n}\n\n/** Processes all the `dependencies` recursively into the `resolvedSchema` as needed\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any>(\n  validator: ValidatorType,\n  dependencies: RJSFSchema[\"dependencies\"],\n  resolvedSchema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  formData?: T\n): RJSFSchema {\n  let schema = resolvedSchema;\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (schema.properties && !(dependencyKey in schema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schema = withDependentProperties(schema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schema = withDependentSchema<T>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as RJSFSchema,\n        formData\n      );\n    }\n    return processDependencies<T>(\n      validator,\n      remainingDependencies,\n      schema,\n      rootSchema,\n      formData\n    );\n  }\n  return schema;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties(\n  schema: RJSFSchema,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param formData- The current formData to assist retrieving a schema\n * @returns - The schema with the dependent schema resolved into it\n */\nexport function withDependentSchema<T>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  dependencyKey: string,\n  dependencyValue: RJSFSchema,\n  formData?: T\n) {\n  const { oneOf, ...dependentSchema } = retrieveSchema<T>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData\n  );\n  schema = mergeSchemas(schema, dependentSchema);\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map((subschema) => {\n    if (typeof subschema === \"boolean\" || !(REF_KEY in subschema)) {\n      return subschema;\n    }\n    return resolveReference<T>(\n      validator,\n      subschema as RJSFSchema,\n      rootSchema,\n      formData\n    );\n  });\n  return withExactlyOneSubschema<T>(\n    validator,\n    schema,\n    rootSchema,\n    dependencyKey,\n    resolvedOneOf,\n    formData\n  );\n}\n\n/** Returns a `schema` with the best choice from the `oneOf` options merged into it\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns  The schema with best choice of oneOf schemas merged into\n */\nexport function withExactlyOneSubschema<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema: RJSFSchema,\n  dependencyKey: string,\n  oneOf: RJSFSchemaDefinition[],\n  formData?: T\n) {\n  const validSubschemas = oneOf.filter((subschema) => {\n    if (typeof subschema === \"boolean\" || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: RJSFSchema = {\n        type: \"object\",\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      };\n      const { errors } = validator.validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n    return false;\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\n      \"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\"\n    );\n    return schema;\n  }\n  const subschema: RJSFSchema = validSubschemas[0] as RJSFSchema;\n  const [dependentSubschema] = splitKeyElementFromObject(\n    dependencyKey,\n    subschema.properties as GenericObjectType\n  );\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(\n    schema,\n    retrieveSchema<T>(validator, dependentSchema, rootSchema, formData)\n  );\n}\n","import isConstant from \"../isConstant\";\nimport { RJSFSchema, ValidatorType } from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any>(\n  validator: ValidatorType,\n  theSchema: RJSFSchema,\n  rootSchema: RJSFSchema = {}\n) {\n  const schema = retrieveSchema<T>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every(\n      (altSchemas) => typeof altSchemas !== \"boolean\" && isConstant(altSchemas)\n    );\n  }\n  return false;\n}\n","import { RJSFSchema, ValidatorType } from \"../types\";\n\nimport isSelect from \"./isSelect\";\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  rootSchema?: RJSFSchema\n) {\n  if (\n    !schema.uniqueItems ||\n    !schema.items ||\n    typeof schema.items === \"boolean\"\n  ) {\n    return false;\n  }\n  return isSelect<T>(validator, schema.items as RJSFSchema, rootSchema);\n}\n","import get from \"lodash/get\";\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport findSchemaDefinition from \"../findSchemaDefinition\";\nimport getMatchingOption from \"./getMatchingOption\";\nimport getSchemaType from \"../getSchemaType\";\nimport isObject from \"../isObject\";\nimport isFixedItems from \"../isFixedItems\";\nimport mergeDefaultsWithFormData from \"../mergeDefaultsWithFormData\";\nimport mergeObjects from \"../mergeObjects\";\nimport { GenericObjectType, RJSFSchema, ValidatorType } from \"../types\";\nimport isMultiSelect from \"./isMultiSelect\";\nimport retrieveSchema, { resolveDependencies } from \"./retrieveSchema\";\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem(\n  schema: RJSFSchema,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): RJSFSchema {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== \"boolean\") {\n        return item;\n      }\n    }\n  } else if (\n    schema.items &&\n    !Array.isArray(schema.items) &&\n    typeof schema.items !== \"boolean\"\n  ) {\n    return schema.items;\n  }\n  if (\n    additionalItems !== AdditionalItemsHandling.Ignore &&\n    isObject(schema.additionalItems)\n  ) {\n    return schema.additionalItems as RJSFSchema;\n  }\n  return {};\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * the each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the default state is desired\n * @param [parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  parentDefaults?: T,\n  rootSchema: RJSFSchema = {},\n  rawFormData?: T,\n  includeUndefinedValues = false\n): T | T[] | undefined {\n  const formData = isObject(rawFormData) ? rawFormData : {};\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(\n      defaults!,\n      schema.default as GenericObjectType\n    ) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition(schema[REF_KEY]!, rootSchema);\n    return computeDefaults<T>(\n      validator,\n      refSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return computeDefaults<T>(\n      validator,\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as RJSFSchema[]).map(\n      (itemSchema: RJSFSchema, idx: number) =>\n        computeDefaults<T>(\n          validator,\n          itemSchema,\n          Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n          rootSchema,\n          formData as T,\n          includeUndefinedValues\n        )\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    schema = schema.oneOf![\n      getMatchingOption(\n        validator,\n        undefined,\n        schema.oneOf as RJSFSchema[],\n        rootSchema\n      )\n    ] as RJSFSchema;\n  } else if (ANY_OF_KEY in schema) {\n    schema = schema.anyOf![\n      getMatchingOption(\n        validator,\n        undefined,\n        schema.anyOf as RJSFSchema[],\n        rootSchema\n      )\n    ] as RJSFSchema;\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === \"undefined\") {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T>(\n            validator,\n            get(schema, [PROPERTIES_KEY, key]),\n            get(defaults, [key]),\n            rootSchema,\n            get(formData, [key]),\n            includeUndefinedValues\n          );\n          if (includeUndefinedValues || computedDefault !== undefined) {\n            acc[key] = computedDefault;\n          }\n          return acc;\n        },\n        {}\n      ) as T;\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: RJSFSchema = getInnerSchemaForArrayItem(\n            schema,\n            AdditionalItemsHandling.Fallback,\n            idx\n          );\n          return computeDefaults<T>(validator, schemaItem, item, rootSchema);\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: RJSFSchema = getInnerSchemaForArrayItem(schema);\n        defaults = rawFormData.map((item: T, idx: number) => {\n          return computeDefaults<T>(\n            validator,\n            schemaItem,\n            get(defaults, [idx]),\n            rootSchema,\n            item\n          );\n        }) as T[];\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect<T>(validator, schema, rootSchema)) {\n          const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries: T[] = (defaults || []) as T[];\n            // populate the array with the defaults\n            const fillerSchema: RJSFSchema = getInnerSchemaForArrayItem(\n              schema,\n              AdditionalItemsHandling.Invert\n            );\n            const fillerDefault = fillerSchema.default;\n            const fillerEntries: T[] = new Array(\n              schema.minItems - defaultsLength\n            ).fill(\n              computeDefaults<any>(\n                validator,\n                fillerSchema,\n                fillerDefault,\n                rootSchema\n              )\n            ) as T[];\n            // then fill up the rest with either the item default or empty, up to minItems\n            return defaultEntries.concat(fillerEntries);\n          }\n        }\n        return defaults ? defaults : [];\n      }\n  }\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<T = any>(\n  validator: ValidatorType,\n  theSchema: RJSFSchema,\n  formData?: T,\n  rootSchema?: RJSFSchema,\n  includeUndefinedValues = false\n) {\n  if (!isObject(theSchema)) {\n    throw new Error(\"Invalid schema: \" + theSchema);\n  }\n  const schema = retrieveSchema<T>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T>(\n    validator,\n    schema,\n    undefined,\n    rootSchema,\n    formData,\n    includeUndefinedValues\n  );\n  if (\n    typeof formData === \"undefined\" ||\n    formData === null ||\n    (typeof formData === \"number\" && isNaN(formData))\n  ) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData);\n  }\n  return formData;\n}\n","import getUiOptions from \"./getUiOptions\";\nimport { UiSchema } from \"./types\";\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<T = any, F = any>(\n  uiSchema: UiSchema<T, F> = {}\n) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://react-jsonschema-form.readthedocs.io/en/latest/usage/widgets/#hidden-widgets\n    \"widget\" in getUiOptions<T, F>(uiSchema) &&\n    getUiOptions<T, F>(uiSchema)[\"widget\"] !== \"hidden\"\n  );\n}\n","import { UI_WIDGET_KEY } from \"../constants\";\nimport { RJSFSchema, UiSchema, ValidatorType } from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, F = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, F> = {},\n  rootSchema?: RJSFSchema\n) {\n  if (uiSchema[UI_WIDGET_KEY] === \"files\") {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T>(\n      validator,\n      schema.items as RJSFSchema,\n      rootSchema\n    );\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n  return false;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from \"../constants\";\nimport getSchemaType from \"../getSchemaType\";\nimport getUiOptions from \"../getUiOptions\";\nimport isCustomWidget from \"../isCustomWidget\";\nimport { RJSFSchema, UiSchema, ValidatorType } from \"../types\";\nimport isFilesArray from \"./isFilesArray\";\nimport isMultiSelect from \"./isMultiSelect\";\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<T = any, F = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, F> = {},\n  rootSchema?: RJSFSchema\n): boolean {\n  const uiOptions = getUiOptions<T, F>(uiSchema);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType(schema);\n\n  if (schemaType === \"array\") {\n    displayLabel =\n      isMultiSelect<T>(validator, schema, rootSchema) ||\n      isFilesArray<T, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === \"object\") {\n    displayLabel = false;\n  }\n  if (schemaType === \"boolean\" && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import isEmpty from \"lodash/isEmpty\";\n\nimport mergeObjects from \"../mergeObjects\";\nimport { ErrorSchema, ValidationData, ValidatorType } from \"../types\";\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function mergeValidationData<T = any>(\n  validator: ValidatorType<T>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(\n      oldErrorSchema,\n      additionalErrorSchema,\n      true\n    ) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from \"lodash/get\";\n\nimport {\n  ALL_OF_KEY,\n  DEPENDENCIES_KEY,\n  ID_KEY,\n  ITEMS_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport isObject from \"../isObject\";\nimport { IdSchema, RJSFSchema, ValidatorType } from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  id?: string | null,\n  rootSchema?: RJSFSchema,\n  formData?: T,\n  idPrefix = \"root\",\n  idSeparator = \"_\"\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T>(validator, schema, rootSchema, formData);\n    return toIdSchema<T>(\n      validator,\n      _schema,\n      id,\n      rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchema<T>(\n      validator,\n      get(schema, ITEMS_KEY) as RJSFSchema,\n      id,\n      rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (schema.type === \"object\" && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchema<T>(\n        validator,\n        isObject(field) ? field : {},\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        idPrefix,\n        idSeparator\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n","import get from \"lodash/get\";\nimport set from \"lodash/set\";\n\nimport {\n  ALL_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from \"../constants\";\nimport { PathSchema, RJSFSchema, ValidatorType } from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any>(\n  validator: ValidatorType,\n  schema: RJSFSchema,\n  name = \"\",\n  rootSchema?: RJSFSchema,\n  formData?: T\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T>(validator, schema, rootSchema, formData);\n    return toPathSchema<T>(validator, _schema, name, rootSchema, formData);\n  }\n\n  const pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, \"\"),\n  } as PathSchema;\n\n  if (\n    ADDITIONAL_PROPERTIES_KEY in schema &&\n    schema[ADDITIONAL_PROPERTIES_KEY] === true\n  ) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchema<T>(\n        validator,\n        schema.items as RJSFSchema,\n        `${name}.${i}`,\n        rootSchema,\n        element\n      );\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchema<T>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property])\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n","import deepEquals from \"./deepEquals\";\nimport {\n  ErrorSchema,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from \"./types\";\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  toIdSchema,\n  toPathSchema,\n} from \"./schema\";\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both the `validator`\n * and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any> implements SchemaUtilsType<T> {\n  rootSchema: RJSFSchema;\n  validator: ValidatorType;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   */\n  constructor(validator: ValidatorType, rootSchema: RJSFSchema) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType,\n    rootSchema: RJSFSchema\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator || !deepEquals(this.rootSchema, rootSchema)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: RJSFSchema,\n    formData?: T,\n    includeUndefinedValues = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel<F = any>(schema: RJSFSchema, uiSchema?: UiSchema<T, F>) {\n    return getDisplayLabel<T, F>(\n      this.validator,\n      schema,\n      uiSchema,\n      this.rootSchema\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @returns - The index of the matched option or 0 if none is available\n   */\n  getMatchingOption(formData: T, options: RJSFSchema[]) {\n    return getMatchingOption<T>(\n      this.validator,\n      formData,\n      options,\n      this.rootSchema\n    );\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray<F = any>(schema: RJSFSchema, uiSchema?: UiSchema<T, F>) {\n    return isFilesArray<T, F>(\n      this.validator,\n      schema,\n      uiSchema,\n      this.rootSchema\n    );\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: RJSFSchema) {\n    return isMultiSelect<T>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: RJSFSchema) {\n    return isSelect<T>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   */\n  mergeValidationData(\n    validationData: ValidationData<T>,\n    additionalErrorSchema?: ErrorSchema<T>\n  ): ValidationData<T> {\n    return mergeValidationData<T>(\n      this.validator,\n      validationData,\n      additionalErrorSchema\n    );\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: RJSFSchema, rawFormData: T) {\n    return retrieveSchema<T>(\n      this.validator,\n      schema,\n      this.rootSchema,\n      rawFormData\n    );\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(\n    schema: RJSFSchema,\n    id?: string | null,\n    formData?: T,\n    idPrefix = \"root\",\n    idSeparator = \"_\"\n  ): IdSchema<T> {\n    return toIdSchema<T>(\n      this.validator,\n      schema,\n      id,\n      this.rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: RJSFSchema, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T>(\n      this.validator,\n      schema,\n      name,\n      this.rootSchema,\n      formData\n    );\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<T = any>(\n  validator: ValidatorType,\n  rootSchema: RJSFSchema\n): SchemaUtilsType<T> {\n  return new SchemaUtils<T>(validator, rootSchema);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(\",\");\n  // Split params\n  const params: string[] = splitted[0].split(\";\");\n  // Get mime-type from params\n  const type: string = params[0].replace(\"data:\", \"\");\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split(\"=\")[0] === \"name\";\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  const binary = atob(splitted[1]);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  // Create the blob object\n  const blob = new window.Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n","import { RangeSpecType } from \"./types\";\nimport { RJSFSchema } from \"./types\";\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec(schema: RJSFSchema) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","import rangeSpec from \"./rangeSpec\";\nimport { InputPropsType, RJSFSchema, UIOptionsType } from \"./types\";\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<T = any, F = any>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || \"text\",\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === \"number\") {\n      inputProps.type = \"number\";\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = \"any\";\n      }\n    } else if (schema.type === \"integer\") {\n      inputProps.type = \"number\";\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from \"./constants\";\nimport getUiOptions from \"./getUiOptions\";\nimport { UiSchema, UISchemaSubmitButtonOptions } from \"./types\";\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: \"Submit\",\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<T = any, F = any>(\n  uiSchema: UiSchema<T, F> = {}\n): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[\n      SUBMIT_BTN_OPTIONS_KEY\n    ] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import { TemplatesType, Registry, UIOptionsType } from \"./types\";\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, F>,\n  T = any,\n  F = any\n>(\n  name: Name,\n  registry: Registry<T, F>,\n  uiOptions: UIOptionsType<T, F> = {}\n): TemplatesType<T, F>[Name] {\n  const { templates } = registry;\n  if (name === \"ButtonTemplates\") {\n    return templates[name];\n  }\n  return (uiOptions[name] as TemplatesType<T, F>[Name]) || templates[name];\n}\n","import React from \"react\";\nimport ReactIs from \"react-is\";\nimport get from \"lodash/get\";\nimport set from \"lodash/set\";\n\nimport { RJSFSchema, Widget, RegistryWidgetsType } from \"./types\";\nimport getSchemaType from \"./getSchemaType\";\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\",\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\",\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, F = any>(AWidget: Widget<T, F>) {\n  let MergedWidget: Widget<T, F> = get(AWidget, \"MergedWidget\");\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions =\n      (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, \"MergedWidget\", MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, F = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, F> = {}\n): Widget<T, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === \"function\" ||\n    (widget && ReactIs.isForwardRef(React.createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, F>(widget as Widget<T, F>);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === \"string\") {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","import getWidget from \"./getWidget\";\nimport { RegistryWidgetsType, RJSFSchema, Widget } from \"./types\";\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, F = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (\n      err.message &&\n      (err.message.startsWith(\"No widget\") ||\n        err.message.startsWith(\"Unsupported widget\"))\n    ) {\n      return false;\n    }\n    throw e;\n  }\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import { CONST_KEY, ENUM_KEY } from \"./constants\";\nimport { RJSFSchema } from \"./types\";\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant(schema: RJSFSchema) {\n  if (\n    ENUM_KEY in schema &&\n    Array.isArray(schema.enum) &&\n    schema.enum.length === 1\n  ) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error(\"schema cannot be inferred as a constant\");\n}\n","import toConstant from \"./toConstant\";\nimport { RJSFSchema, EnumOptionsType } from \"./types\";\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList(\n  schema: RJSFSchema\n): EnumOptionsType[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as RJSFSchema & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== \"production\") {\n    console.warn(\n      \"The enumNames property is deprecated and may be removed in a future major release.\"\n    );\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label =\n        (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) ||\n        String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as RJSFSchema;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from \"./types\";\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(\n  properties: string[],\n  order?: string[]\n): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1\n      ? `properties '${arr.join(\"', '\")}'`\n      : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter(\n    (prop) => prop === \"*\" || propertyHash[prop]\n  );\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf(\"*\");\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\n        `uiSchema order list does not contain ${errorPropList(rest)}`\n      );\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = \"0\" + s;\n  }\n  return s;\n}\n","import { DateObject } from \"./types\";\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(\n  dateString?: string,\n  includeTime = true\n): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import get from \"lodash/get\";\n\nimport { RJSFSchema, UIOptionsType } from \"./types\";\nimport asNumber from \"./asNumber\";\nimport guessType from \"./guessType\";\n\nconst nums = new Set<any>([\"number\", \"integer\"]);\n\n/** Returns the real value for a select widget due to a silly limitation in the DOM which causes option change event\n * values to always be retrieved as strings. Uses the `schema` to help determine the value's true type. If the value is\n * an empty string, then the `emptyValue` from the `options` is returned, falling back to undefined.\n *\n * @param schema - The schema to used to determine the value's true type\n * @param [value] - The value to convert\n * @param [options] - The UIOptionsType from which to potentially extract the emptyValue\n * @returns - The `value` converted to the proper type\n */\nexport default function processSelectValue<T = any, F = any>(\n  schema: RJSFSchema,\n  value?: any,\n  options?: UIOptionsType<T, F>\n) {\n  const { enum: schemaEnum, type, items } = schema;\n  if (value === \"\") {\n    return options && options.emptyValue !== undefined\n      ? options.emptyValue\n      : undefined;\n  }\n  if (type === \"array\" && items && nums.has(get(items, \"type\"))) {\n    return value.map(asNumber);\n  }\n  if (type === \"boolean\") {\n    return value === \"true\";\n  }\n  if (nums.has(type)) {\n    return asNumber(value);\n  }\n\n  // If type is undefined, but an enum is present, try and infer the type from\n  // the enum values\n  if (Array.isArray(schemaEnum)) {\n    if (schemaEnum.every((x: any) => nums.has(guessType(x)))) {\n      return asNumber(value);\n    }\n    if (schemaEnum.every((x: any) => guessType(x) === \"boolean\")) {\n      return value === \"true\";\n    }\n  }\n\n  return value;\n}\n","import { RJSFSchema, RJSFSchemaDefinition } from \"./types\";\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue(schema: RJSFSchema): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as RJSFSchema);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as RJSFSchema);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: RJSFSchemaDefinition) =>\n      schemaRequiresTrueValue(subSchema as RJSFSchema);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import React from \"react\";\n\nimport deepEquals from \"./deepEquals\";\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(\n  component: React.Component,\n  nextProps: any,\n  nextState: any\n) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { DateObject } from \"./types\";\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import pad from \"./pad\";\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return \"\";\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n"],"names":["isObject","thing","File","Array","isArray","allowAdditionalItems","schema","additionalItems","console","warn","asNumber","value","undefined","test","n","Number","valid","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEFINITIONS_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","UI_FIELD_KEY","UI_WIDGET_KEY","UI_OPTIONS_KEY","getUiOptions","uiSchema","Object","keys","filter","key","indexOf","reduce","options","error","substring","canExpand","formData","additionalProperties","expandable","maxProperties","length","deepEquals","a","b","isEqualWith","obj","other","splitKeyElementFromObject","object","remaining","omit","findSchemaDefinition","$ref","rootSchema","ref","startsWith","decodeURIComponent","Error","current","jsonpointer","get","theRef","subSchema","getMatchingOption","validator","i","option","properties","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","allOf","slice","push","assign","isValid","guessType","getSchemaType","type","const","enum","includes","find","isFixedItems","items","every","item","mergeDefaultsWithFormData","defaults","defaultsArray","mapped","idx","acc","mergeObjects","obj1","obj2","concatArrays","left","right","concat","isConstant","mergeSchemas","union","resolveCondition","if","expression","then","else","otherwise","resolvedSchemaLessConditional","conditionalSchema","retrieveSchema","resolveSchema","resolveReference","resolvedSchema","resolveDependencies","allOfSubschema","$refSchema","localSchema","stubExistingAdditionalProperties","theSchema","aFormData","forEach","set","rawFormData","entries","propName","propSchema","rawPropData","propData","resolvedPropSchema","mergeAllOf","e","resolvedSchemaWithoutAllOf","hasAdditionalProperties","dependencies","remainingSchema","oneOf","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","dependentSchema","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","errors","validateFormData","dependentSubschema","isSelect","altSchemas","isMultiSelect","uniqueItems","AdditionalItemsHandling","getInnerSchemaForArrayItem","Ignore","computeDefaults","parentDefaults","includeUndefinedValues","default","refSchema","itemSchema","computedDefault","schemaItem","Fallback","minItems","defaultsLength","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","isCustomWidget","isFilesArray","itemsSchema","format","getDisplayLabel","uiOptions","label","displayLabel","schemaType","mergeValidationData","validationData","additionalErrorSchema","oldErrors","errorSchema","oldErrorSchema","toErrorList","isEmpty","toIdSchema","id","idPrefix","idSeparator","_schema","$id","idSchema","name","field","fieldId","toPathSchema","pathSchema","replace","element","property","SchemaUtils","constructor","getValidator","doesSchemaUtilsDiffer","createSchemaUtils","dataURItoBlob","dataURI","splitted","split","params","param","binary","atob","array","charCodeAt","blob","window","Blob","Uint8Array","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","getInputProps","defaultType","autoDefaultStepAny","inputProps","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","boolean","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","React","createElement","getWidget","widget","registeredWidgets","ReactIs","isForwardRef","isMemo","registeredWidget","hasWidget","err","message","localToUTC","dateString","Date","toJSON","toConstant","optionsList","schemaWithEnumNames","enumNames","process","String","aSchemaDef","aSchema","title","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","join","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","pad","num","width","s","parseDateString","includeTime","year","month","day","hour","minute","second","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","nums","processSelectValue","schemaEnum","emptyValue","has","x","schemaRequiresTrueValue","schemaSome","some","shouldRender","component","nextProps","nextState","state","toDateString","dateObject","time","utcTime","UTC","utcToLocal","jsonDate","yyyy","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds"],"mappings":"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"}